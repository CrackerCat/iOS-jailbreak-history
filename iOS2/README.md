---
title: "iOS 越狱史及技术简析 - iOS 2"
date: 2019-12-30T18:02:59+08:00
draft: false
tags: ["iPhone","jailbreak"]
layout: post

---
# 前言

在整理这篇文章的时候，我一直在犹豫要不要写上这个版本更新的安全机制，因为实际上真正的越狱利用部分与他们并没有关系，而因为是刚刚加入系统中，后续对他们的收尾工作并不复杂，但思索再三，还是将他们写下来了，原因无他：只有一步一步追溯苹果的更新脚步，才能理解在后续版本中他们做的安全措施。

# 回顾

在上一篇文章中，我们已经提到了苹果对 iOS 1 的安全保护正在一步一步进化中。截止 iOS 1.1.5，从上至下层级排列，iOS 的安全措施如下

| 名称            | 出现版本  | 说明                                                         |
| --------------- | --------- | ------------------------------------------------------------ |
| Secure Boot     | iOS 1.0   | 启动链的每个环节都会负责验证下一阶段的签名                   |
| fsroot 只读     | iOS 1.0   | 系统盘 /dev/disk0s1 默认是只读的                             |
| AFC Restriction | iOS 1.0   | iPhone 通过 AFC 服务与电脑进行数据交换，这个服务默认只允许宿主机访问`/Media`目录 |
| 固件加密        | iOS 1.1   | `IMG2`格式的系统固件通过`Key 0x837`被加密                    |
| mobile 用户     | iOS 1.1.3 | 在此之前，所用应用程序均使用`root`权限运行                   |

应该说，这个阶段的越狱并没有什么难度。越狱社区正处于萌芽状态，尽管并没有原生的中文支持，威锋社区已经通过修改内核文件的方法让 iPhone 成功支持了中文输入法与中文短信的显示。

随后，2008 年 7 月 1 日， 苹果推出了 iOS 2 更新，同时公布了 iPhone 3G。 iOS 2 预装在 iPhone 3G 上，iPhone 1代也可以升级到 iOS 2。

# 代码签名与沙盒

这次更新之后，App Store 开始内置在 iPhone 内，这意味着用户可以自己下载并安装应用程序了。相对应的，iOS 新增了以下安全机制:

- 强制代码签名
  - 所有可执行程序、库、甚至内存中的代码，都必须经过苹果签名才能运行
- 应用程序沙盒
  - 应用程序默认情况下运行在沙盒中，限制其所能访问的资源(包括但不限于系统调用，文件等)

上述两个安全机制都被注册到 TrustedBSD 中的 Mandatory Access Control 扩展（MACF）里。TrustedBSD 是一个内核扩展程序的集合，从 Mac OS X 10.5（2007 年 10 月 26 日发布）开始，苹果将整个 TrustedBSD 都移植到了 XNU 内核中，代号为 Seatbelt，所以 Mac OS X 和 iOS 也自然拥有了 MACF。

MACF 的架构大致如下:

```
    ^
    |
    |
 User Space
+------------------------------------------------------------+
|Ker|nel Space                                               |
|   |     +----------+            +-----------------------+  |
|   |     |          |            |                       |  |
|   |     |  MACF    |------------>     +-----------+     |  |
|   v     |          |            |     |  Policy 1 |     |  |
|         +----------+            |     +----+------+     |  |
|    Kernel   |  Access Event     |          |            |  |
|             v                   |          v            |  |
|    +--------+---------------+   |     +----+------+     |  |
|    |  Kernel Implmentation  |   |     |  Policy 2 |     |  |
|    +------------------------+   |     +----+------+     |  |
|    |    Kernel Object       |   |          |            |  |
|    +------------------------+   |          |            |  |
|             |                   |          |            |  |
|             |                   |          |            |  |
|    +--------v---------------+   |     +----v------+     |  |
|    |  File System, Network  |   |     |  Policy N |     |  |
|    +------------------------+   |     +-----------+     |  |
|                                 |                       |  |
|                                 +-----------------------+  |
|                                                            |
+------------------------------------------------------------+
```
安全策略可以编译时静态链接到内核，也可以在引导时加载，甚至在运行时动态加载。在主体访问客体时，MACF 会调用所有的安全策略，只有当所有的安全策略均表示同意，MACF 才会授权这次访问。

```
    +--------------------+      +-------------------+
    | User mode process  |      |  User Mode Daemon |
    +---------|-^--------+      +---------^---------+
+-------------|-|--------------------------------------------------+
              | |                         |
    +---------v-+--------+                |
    | sysent/mach_trap_tb|                |
    +---------|-^--------+           +----+---+
              | |                    | Policy |
    +---------v-+--------+     +----->        |
    |  syscall/trap #n   |     |     | Module |
    +---------|-^--------+     |     +--------+
              | |              |
    +---------v-+--------+     |
    |     M  A  C  F     ｜-----
    +--------------------+

```
在具体实现中，每次 MACF 均会检查是否有策略 hook 了 sycall/mach trap，如果是，那么就会拉起这个策略，由该策略判断允许还是阻止继续执行。

## 代码签名 (AppleMobileFileIntegrity)

从上述 MACF 架构中我们知道，要想在 iOS 实现代码签名机制，就需要自己提供一个验证代码签名的策略，然后注册相关 hook，这个工作由`AppleMobileFileIntegrity.kext`完成。它既不防止权限提升也不阻止未授权访问资源，它的工作仅限于保证文件的完整性(Integrity)和认证性(Authentication)。

由于代码签名验证的逻辑非常复杂，一般情况下不适合在内核态运行，所以 AMFI 由两部分组成，用户态的daemon - `/usr/libexec/amfid` 和内核态的`AppleMobileFileIntegrity.kext`组成。后者会在内核一初始化完成就注册到 MACF 的策略，如果初始化注册时出错，就会导致 kernel panic。而在初始化完成后想 unload 这个 kext，则会报错 -- "Cannot unload AMFI - policy is not dynamic"，然后接着给你来个 panic。与之相反，前者可以说是 AMFI 的阿克琉斯之踵，几乎在之后版本的所有越狱中都会拿这个下手绕过代码签名。

## 沙盒

与 AMFI 相同，沙盒也由一个用户态`/usr/libexec/sandboxd`和一个kext`Sandbox.kext`组成。在初始版本中(Sandbox<=165, iOS 1 ~ iOS 4)，沙盒机制是黑名单制的，这就意味着这个机制很容易被通过“白加黑”的手段绕过。所以苹果在 iOS 5 的时候重做了这个机制，重命名为"App Sandbox"，引入了容器(Container)的概念。

